esphome:
  name: ${device_name}
  friendly_name: ${device_name}
  project: 
    name: agn.remote
    version: "0.1"

substitutions:
  device_name: esphome-n1-00
  timezone: "Europe/London"
  sntp_update_interval: 6h
  sntp_server_1: "0.pool.ntp.org"
  sntp_server_2: "1.pool.ntp.org"
  sntp_server_3: "2.pool.ntp.org"  


# ToDo: Get the charge controller working and enable charging; otherwise it doesn't charge the battery while running this firmware
  # I've got Arduino code for this here: https://github.com/webash/MeshCore/blob/ff3b84dce5ae8051a901cd3400a2906dd848e864/variants/arduino_nesso_n1/expander.cpp#L97


esp32:
  board: esp32-c6-devkitc-1
  framework:
    type: esp-idf

external_components:
# wants the Arduino framework, which doesn't work on esp32-c6
#   - source: github://GeeDeePeeTee/esphome-bq27220
#     components: [bq27220]

# my modified version of the above component swapping in esphome libraries
  - source: 
      type: git
      url: https://github.com/webash/esphome-bq27220
      ref: convertto-esphome-libraries
    components: [bq27220]
    refresh: 120s
    

# Enable logging
logger:
  id: component_logger

# Enable Home Assistant API
api:
  id: component_api
  encryption:
    key: !secret api_encryption

ota:
  - id: component_ota_esphome
    platform: esphome
    password: !secret ota_password

wifi:
  id: component_wifi
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "${device_name} Fallback Hotspot"
    password: !secret fallback_ap_password

captive_portal:
  id: component_captiveportal

web_server:
  id: component_webserver
  port: 80
  auth: 
    username: !secret web_server_username
    password: !secret web_server_password

# debug:
#   id: component_debug

time:
  - platform: sntp
    id: component_sntp_time
  # Define the timezone of the device
    timezone: "${timezone}"
  # Change sync interval from default 5min to 6 hours (or as set in substitutions)
    update_interval: ${sntp_update_interval}
  # Set specific sntp servers to use
    servers: 
      - "${sntp_server_1}"
      - "${sntp_server_2}"
      - "${sntp_server_3}"    
  # Publish the time the device was last restarted
    on_time_sync:
      then:
        # Update last restart time, but only once.
        - if:
            condition:
              lambda: 'return id(component_diagnostic_lastrestart).state == "";'
            then:
              - text_sensor.template.publish:
                  id: component_diagnostic_lastrestart
                  state: !lambda 'return id(component_sntp_time).now().strftime("%a %d %b %Y - %I:%M:%S %p");'

i2c:
  - id: component_i2c0
    scl: GPIO8 # warns about strapping pin; is what it is
    sda: GPIO10

spi:
  - id: component_spi0
    type: single
    mosi_pin: GPIO21
    clk_pin: GPIO20
  
pi4ioe5v6408:
  # Buttons and LoRa control
  - id: component_expander_p0
    address: 0x43
    i2c_id: component_i2c0
  # Power/UI: LCD reset, LCD backlight, GROVE power, VIN detect, LED
  - id: component_expander_p1
    address: 0x44
    i2c_id: component_i2c0

i2c_device:
  # does nothing right now, but this is where the AW32001E charge controller is
  - id: component_charge_controller
    address: 0x49
    i2c_id: component_i2c0
  # does nothing right now, but this is where the BMI270 6 axis IMU is
  - id: component_imu0
    address: 0x68
    i2c_id: component_i2c0
  # does nothing right now, but this is where the BMI270 6 axis IMU is (docs says it has 2x addresses)
  - id: component_imu1
    address: 0x69
    i2c_id: component_i2c0

output:
  - platform: gpio # couldn't get ledc to work for pwm, because of the expander
    id: component_output_light_lcd_gpio
    pin:
      pi4ioe5v6408: component_expander_p1
      number: 6
      mode:
        output: true
  - id: component_output_buzzer
    platform: ledc
    pin: GPIO11
  - id: component_output_led_green_gpio
    platform: gpio # also couldn't find a way to get PWM to work for this LED over the expander, despite Nesso N1's documentation suggesting it should be posible. I'm guessing the expander library OR the LEDC library just doesn't work for it.
    pin:
      pi4ioe5v6408: component_expander_p1
      number: 7
      inverted: true
      mode:
        output: true


remote_transmitter:
  id: component_ir_transmitter
  pin: GPIO9 # warns about strapping pin; safe because its used for output with a high impedance device
  # Infrared remotes use a 50% carrier signal (copied from esphome documentation)
  carrier_duty_percent: 50%

button:
  - platform: template
    id: component_ir_sony_power_on
    name: IR - Sony - Power On
    on_press:
      # from: https://community.home-assistant.io/t/extracting-sony-ir-transmitter-pronto-codes-for-sony-str-db930-guide/784161
      - remote_transmitter.transmit_pronto:
          transmitter_id: component_ir_transmitter
          data: "0000 0066 0000 000d 005f 0018 0018 0018 0030 0018 0030 0018 0030 0018 0018 0018 0030 0018 0018 0018 0018 0017 0018 0018 0018 0017 0018 0018 002f 0429"

  # System control buttons
  - platform: restart
    id: component_button_restart
    name: "Restart"
    entity_category: config
  - platform: factory_reset
    id: component_button_factoryreset
    name: "Factory Reset"
    entity_category: config
  - platform: safe_mode
    id: component_button_safemode
    name: Safe Mode Boot
    internal: False
    entity_category: config

text_sensor:
  # Network diagnostic information
  - platform: wifi_info
    dns_address:
      id: component_diagnostic_dns
      name: "DNS address"
      icon: mdi:network-pos
      entity_category: diagnostic
    ip_address:
      id: component_diagnostic_ipaddr
      name: "IP Address"
      icon: mdi:ip-network
      entity_category: diagnostic
    mac_address:
      id: component_diagnostic_macaddr
      name: "MAC Address"
      icon: mdi:network-pos
      entity_category: diagnostic
    ssid:
      id: component_diagnostic_ssid
      name: "WiFi SSID"
      entity_category: diagnostic
      

  # debug information; when 'debug:' keyword is enabled
  # - platform: debug
  #   device:
  #     id: component_diagnostic_deviceinfo
  #     name: "Device Info"
  #     entity_category: diagnostic
  #   reset_reason:
  #     id: component_diagnostic_resetreason
  #     name: "Reset Reason"
  #     entity_category: diagnostic
  # Last restart
  - platform: template
    name: 'Last Restart'
    id: component_diagnostic_lastrestart
    icon: mdi:clock
    entity_category: diagnostic
  #  Creates a sensor of the uptime of the device, in formatted days, hours, minutes and seconds
  - platform: template
    id: component_uptime_humanreadable
    name: "Uptime"
    entity_category: diagnostic
    icon: mdi:clock-start
    lambda: |-
      static char buf[64];  // static buffer so we can return pointer safely

      int seconds = (id(component_uptime_sensor).state);
      int days = seconds / (24 * 3600);
      seconds = seconds % (24 * 3600);
      int hours = seconds / 3600;
      seconds = seconds % 3600;
      int minutes = seconds /  60;
      seconds = seconds % 60;

      if (days > 3650) {
        snprintf(buf, sizeof(buf), "Starting up");
      } else if (days > 0) {
          snprintf(buf, sizeof(buf), "%dd %dh %dm %ds", days, hours, minutes, seconds);
      } else if (hours > 0) {
          snprintf(buf, sizeof(buf), "%dh %dm %ds", hours, minutes, seconds);
      } else if (minutes > 0) {
          snprintf(buf, sizeof(buf), "%dm %ds", minutes, seconds);
      } else {
          snprintf(buf, sizeof(buf), "%ds", seconds);
      }

      return std::string(buf);

binary_sensor:
  - id: component_button_front
    platform: gpio
    pin:
      pi4ioe5v6408: component_expander_p0
      number: 0
      mode:
        input: true
        pullup: true
      inverted: true
    on_press:
      - then:
        - light.turn_on: component_light_lcd_binary
        - output.turn_on: component_output_buzzer
        - while:
            condition:
              binary_sensor.is_on: component_button_front
            then:
            - output.ledc.set_frequency:
                id: component_output_buzzer
                frequency: "1000Hz"
            - output.set_level:
                id: component_output_buzzer
                level: 50%
            - delay: 0.5s
            - output.ledc.set_frequency:
                id: component_output_buzzer
                frequency: "500Hz"
            - output.set_level:
                id: component_output_buzzer
                level: 100%
        - output.turn_off: component_output_buzzer
  - id: component_button_side
    platform: gpio
    pin:
      pi4ioe5v6408: component_expander_p0
      number: 1
      mode:
        input: true
        pullup: true
      inverted: true
    on_press: 
      then:
        - light.turn_off: component_light_lcd_binary
        - output.turn_off: component_output_buzzer

sensor:
  # Diagnostic sensors
  - platform: uptime
    name: "Uptime Sensor"
    id: component_uptime_sensor
    entity_category: diagnostic
  - platform: wifi_signal
    id: component_diagnostic_wifi_signal
    name: "WiFi Signal"
    entity_category: diagnostic
  - platform: internal_temperature
    id: component_diagnostic_internal_temperature
    name: "Internal temperature"
    entity_category: diagnostic

  - platform: bq27220
    # on address: 0x55
    voltage:
      name: "Battery Voltage"
      id: component_batt_voltage
      entity_category: diagnostic
    current:
      name: "Battery Current"
      id: component_batt_current
      entity_category: diagnostic
    soc:
      name: "Battery SOC"
      id: component_batt_soc
      entity_category: diagnostic
    remaining_capacity:
      name: "Battery Remaining Capacity"
      id: component_batt_remaining_capacity
      entity_category: diagnostic
    temperature:
      name: "Battery Temperature"
      id: component_batt_temperature
      entity_category: diagnostic
    full_charge_capacity:
      name: "Battery Full Charge Capacity"
      id: component_batt_full_charge_capacity
      entity_category: diagnostic
    design_capacity:
      name: "Battery Design Capacity"
      id: component_batt_design_capacity
      entity_category: diagnostic
    state_of_health:
      name: "Battery State of Health"
      id: component_batt_soh
      entity_category: diagnostic
    device_number:
      name: "Battery Device ID"
      id: component_bq27220_battery_device_id
      entity_category: diagnostic
  # Watch this component or modify it myself to get the BMI270 on its own:
  # https://github.com/DennisGaida/m5stack-atoms3r-components/blob/main/components/bmi270_bmm150/bmi270_bmm150.cpp
  # https://github.com/esphome/feature-requests/issues/3052

light:
  # can't get monochromatic light with PWM working due to the expander; esphome doesn't want
  # - platform: monochromatic
  #   id: component_light_lcd
  #   name: LCD backlight
  #   output: light_lcd_gpio
  #   initial_state: 
  #     brightness: 100%
  #   restore_mode: ALWAYS_ON
  - platform: binary
    id: component_light_lcd_binary
    name: LCD Backlight (Binary)
    output: component_output_light_lcd_gpio
    initial_state: 
      brightness: 1
    restore_mode: RESTORE_DEFAULT_ON
  - platform: binary # wanted monochromatic, but see output pin configuration for more detail
    id: component_led_green
    name: Green LED
    output: component_output_led_green_gpio
    restore_mode: RESTORE_DEFAULT_OFF

# some configuation done here, but not all
# sx126x:
#   dio1_pin: GPIO14
#   cs_pin: GPIO23
#   busy_pin: GPIO19
#   rst_pin:
#     pi4ioe5v6408: expander_p0 # doesn't support expander, so will have to be done manually?
#     number: 7
#   pa_power: 22
#   # bandwidth: 125_0kHz
#   crc_enable: true
#   frequency: 433920000 # what should we use?
#   modulation: LORA
#   hw_version: sx1262
#   rf_switch: true
#   sync_value: [0x14, 0x24]
#   preamble_size: 8
#   spreading_factor: 7
#   coding_rate: CR_4_6
#   tcxo_voltage: 1_8V
#   tcxo_delay: 5ms
    
touchscreen:
  - id: component_touchscreen
    platform: ft63x6
    i2c_id: component_i2c0
    display: component_display
    address: 0x38
    # interrupt_pin: # seems to never send an interrupt, so no touch events are recorded
    #   number: GPIO3
    #   allow_other_uses: True
    # on_touch:
    #   - lambda: |-
    #       ESP_LOGI("touchscreen", "x=%d, y=%d, x_raw=%d, y_raw=%0d",
    #           touch.x,
    #           touch.y,
    #           touch.x_raw,
    #           touch.y_raw
    #           );
    # on_update:
    #   - lambda: |-
    #       for (auto touch: touches)  {
    #           if (touch.state <= 2) {
    #             ESP_LOGI("touchscreen", "id=%d x=%d, y=%d", touch.id, touch.x, touch.y);
    #           }
    #       }
    # on_release: 
    #   - lambda: |-
    #       ESP_LOGI("touchscreen", "released");

display:
  - id: component_display
    platform: mipi_spi
    model: ST7789V
    dimensions:
      height: 240
      width: 135
      offset_height: 40
      offset_width: 52
    cs_pin: GPIO17
    dc_pin: GPIO16
    invert_colors: true
    update_interval: 50ms
    reset_pin:
      pi4ioe5v6408: component_expander_p1
      number: 1
      mode:
        output: true
    lambda: |-
      auto black = Color(0, 0, 0);
      auto red = Color(255, 0, 0);
      auto green = Color(0, 255, 0);
      auto blue = Color(0, 0, 255);
      auto white = Color(255, 255, 255);
      it.fill(id(color_bg));
      // it.print(0, 0, id(font_standard), id(color_green), "Hello ST7789!");
      it.printf(0, 0, id(font_standard), black, "%.1fV", id(component_batt_voltage).state);
      it.filled_circle(it.get_width() / 2, it.get_height() / 2, 50, id(color_purple));
      it.filled_circle((it.get_width() / 2) - 40, 32, 15, black);
      it.filled_circle((it.get_width() / 2) - 20, 32, 15, red);
      it.filled_circle((it.get_width() / 2), 32, 15, green);
      it.filled_circle((it.get_width() / 2) + 20, 32, 15, blue);
      it.filled_circle((it.get_width() / 2) + 40, 32, 15, white);
      
      auto touch = id(component_touchscreen)->get_touch();
      if (touch) {// or touch.has_value()
        it.filled_circle(touch.value().x, touch.value().y, 10, white);
      }

font:
  - id: font_standard
    file: "gfonts://Roboto"
    size: 14

color:
  - id: color_bg
    red_int: 226
    green_int: 77
    blue_int: 2
  - id: color_red
    red: 100%
    green: 0
    blue: 0
  - id: color_green
    red: 0
    green: 100%
    blue: 0
  - id: color_blue
    red: 0
    green: 0
    blue: 100%
  - id: color_purple
    red_int: 77
    green_int: 2
    blue_int: 226
